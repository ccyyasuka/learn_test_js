<!DOCTYPE html>
<html lang="zh-cmn-Hans">
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="x-ua-compatible" content="IE=edge, chrome=1" />
		<title>debounce</title>
		<style></style>
	</head>

	<body>
		<script>
			class Node {
				constructor(val) {
					this.val = val;
					this.next = null;
				}
			}
			class List {
				constructor() {
					this.head = null;
					this.tail = null;
				}
				append(val) {
					let curNode = new Node(val);
					if (!this.head) {
						this.head = curNode;
						this.tail = curNode;
					} else {
						this.tail.next = curNode;
						this.tail = curNode;
					}
				}
				printList() {
					let current = this.head;
					while (current) {
						console.log(current.val);
						current = current.next;
						//这里不会有浅拷贝的问题，因为current，head和current.next都是存储了一个地址，
						// 这里的操作只是把新地址赋值给了current，而不是在修改current和head对应的堆空间中的数据
					}
				}
			}
			function deletion(list0) {
				let slow = list0.head;
				let fast = list0.head;
				while (1) {
					if (fast.val === slow.val) {
						fast = fast.next;
					} else {
						slow.next = fast;
						slow = fast;
					}
					if (!fast) {
						break;
					}
				}
			}
			let list0 = new List();
			list0.append(1);
			list0.append(1);
			list0.append(1);
			list0.append(2);
			list0.append(2);
			list0.append(2);
			list0.append(3);
			deletion(list0);
			list0.printList();
			list0.printList();
		</script>
	</body>
</html>
